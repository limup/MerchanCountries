{"ast":null,"code":"import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber, OperatorSubscriber } from './OperatorSubscriber';\nexport function groupBy(keySelector, elementOrOptions, duration, connector) {\n  return operate(function (source, subscriber) {\n    var element;\n\n    if (!elementOrOptions || typeof elementOrOptions === 'function') {\n      element = elementOrOptions;\n    } else {\n      duration = elementOrOptions.duration;\n      element = elementOrOptions.element;\n      connector = elementOrOptions.connector;\n    }\n\n    var groups = new Map();\n\n    var notify = function notify(cb) {\n      groups.forEach(cb);\n      cb(subscriber);\n    };\n\n    var handleError = function handleError(err) {\n      return notify(function (consumer) {\n        return consumer.error(err);\n      });\n    };\n\n    var activeGroups = 0;\n    var teardownAttempted = false;\n    var groupBySourceSubscriber = new OperatorSubscriber(subscriber, function (value) {\n      try {\n        var key = keySelector(value);\n        var group = groups.get(key);\n\n        if (!group) {\n          groups.set(key, group = connector ? connector() : new Subject());\n          var grouped = createGroupedObservable(key, group);\n          subscriber.next(grouped);\n\n          if (duration) {\n            var durationSubscriber = createOperatorSubscriber(group, function () {\n              group.complete();\n              durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();\n            }, undefined, undefined, function () {\n              return groups.delete(key);\n            });\n            groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber));\n          }\n        }\n\n        group.next(element ? element(value) : value);\n      } catch (err) {\n        handleError(err);\n      }\n    }, function () {\n      return notify(function (consumer) {\n        return consumer.complete();\n      });\n    }, handleError, function () {\n      return groups.clear();\n    }, function () {\n      teardownAttempted = true;\n      return activeGroups === 0;\n    });\n    source.subscribe(groupBySourceSubscriber);\n\n    function createGroupedObservable(key, groupSubject) {\n      var result = new Observable(function (groupSubscriber) {\n        activeGroups++;\n        var innerSub = groupSubject.subscribe(groupSubscriber);\n        return function () {\n          innerSub.unsubscribe();\n          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\n        };\n      });\n      result.key = key;\n      return result;\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/limup/Documents/teste/MerchanCountries/MerchanCountriesAngular/MerchanCountriesAngular/ClientApp/node_modules/rxjs/dist/esm/internal/operators/groupBy.js"],"names":["Observable","innerFrom","Subject","operate","createOperatorSubscriber","OperatorSubscriber","groupBy","keySelector","elementOrOptions","duration","connector","source","subscriber","element","groups","Map","notify","cb","forEach","handleError","err","consumer","error","activeGroups","teardownAttempted","groupBySourceSubscriber","value","key","group","get","set","grouped","createGroupedObservable","next","durationSubscriber","complete","unsubscribe","undefined","delete","add","subscribe","clear","groupSubject","result","groupSubscriber","innerSub"],"mappings":"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","sourcesContent":["import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber, OperatorSubscriber } from './OperatorSubscriber';\nexport function groupBy(keySelector, elementOrOptions, duration, connector) {\n    return operate((source, subscriber) => {\n        let element;\n        if (!elementOrOptions || typeof elementOrOptions === 'function') {\n            element = elementOrOptions;\n        }\n        else {\n            ({ duration, element, connector } = elementOrOptions);\n        }\n        const groups = new Map();\n        const notify = (cb) => {\n            groups.forEach(cb);\n            cb(subscriber);\n        };\n        const handleError = (err) => notify((consumer) => consumer.error(err));\n        let activeGroups = 0;\n        let teardownAttempted = false;\n        const groupBySourceSubscriber = new OperatorSubscriber(subscriber, (value) => {\n            try {\n                const key = keySelector(value);\n                let group = groups.get(key);\n                if (!group) {\n                    groups.set(key, (group = connector ? connector() : new Subject()));\n                    const grouped = createGroupedObservable(key, group);\n                    subscriber.next(grouped);\n                    if (duration) {\n                        const durationSubscriber = createOperatorSubscriber(group, () => {\n                            group.complete();\n                            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();\n                        }, undefined, undefined, () => groups.delete(key));\n                        groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber));\n                    }\n                }\n                group.next(element ? element(value) : value);\n            }\n            catch (err) {\n                handleError(err);\n            }\n        }, () => notify((consumer) => consumer.complete()), handleError, () => groups.clear(), () => {\n            teardownAttempted = true;\n            return activeGroups === 0;\n        });\n        source.subscribe(groupBySourceSubscriber);\n        function createGroupedObservable(key, groupSubject) {\n            const result = new Observable((groupSubscriber) => {\n                activeGroups++;\n                const innerSub = groupSubject.subscribe(groupSubscriber);\n                return () => {\n                    innerSub.unsubscribe();\n                    --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\n                };\n            });\n            result.key = key;\n            return result;\n        }\n    });\n}\n"]},"metadata":{},"sourceType":"module"}